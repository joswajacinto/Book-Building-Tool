{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.rewindStack = rewindStack;\nexports.parse = parse;\n\nvar _compat = require('./compat');\n\nfunction parser(tokens, options) {\n  var root = {\n    tagName: null,\n    children: []\n  };\n  var state = {\n    tokens: tokens,\n    options: options,\n    cursor: 0,\n    stack: [root]\n  };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n\n      if (parentTagName === tagName) {\n        break;\n      }\n\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n\n      currentIndex--;\n    }\n  }\n\n  return false;\n}\n\nfunction rewindStack(stack, newLength, childrenEndPosition, endPosition) {\n  stack[newLength].position.end = endPosition;\n\n  for (var i = newLength + 1, len = stack.length; i < len; i++) {\n    stack[i].position.end = childrenEndPosition;\n  }\n\n  stack.splice(newLength);\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n\n    if (token.close) {\n      var index = stack.length;\n      var shouldRewind = false;\n\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true;\n          break;\n        }\n      }\n\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n\n      if (shouldRewind) {\n        rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          rewindStack(stack, currentIndex, token.position.start, token.position.start);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    var position = {\n      start: token.position.start,\n      end: attrToken.position.end\n    };\n    var elementNode = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children,\n      position: position\n    };\n    nodes.push(elementNode);\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n\n    if (hasChildren) {\n      var size = stack.push({\n        tagName: tagName,\n        children: children,\n        position: position\n      });\n      var innerState = {\n        tokens: tokens,\n        options: options,\n        cursor: cursor,\n        stack: stack\n      };\n      parse(innerState);\n      cursor = innerState.cursor;\n      var rewoundInElement = stack.length === size;\n\n      if (rewoundInElement) {\n        elementNode.position.end = tokens[cursor - 1].position.end;\n      }\n    }\n  }\n\n  state.cursor = cursor;\n}","map":null,"metadata":{},"sourceType":"script"}